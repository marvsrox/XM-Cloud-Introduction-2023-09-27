import { vi, describe, it, assert, beforeAll, expect, beforeEach } from 'vitest'
import { CH1Node, serializeCH1RichText } from '../src/dom/data.js'
import { clearFetchCache, fetchAndRevalidate } from '../src/fetch.js'
const yesterday = new Date(2000, 1, 1, 0, 0, 0)
const yesterdayNoon = new Date(2000, 1, 2, 12, 0, 0)
const today = new Date(2000, 1, 2, 0, 0, 0)
const todayNoon = new Date(2000, 1, 2, 12, 0, 0)
describe('Fetch', () => {
  beforeEach(() => {
    // vi.useFakeTimers()
    vi.setSystemTime(todayNoon)
    clearFetchCache()
    phases1.length = 0
    phases2.length = 0
  })
  var phases1: [t: string, p: string][] = []
  var phases2: [t: string, p: string][] = []
  async function callback1(response: Response, phase: string) {
    phases1.push([await response.clone().text(), phase])
  }
  async function callback2(response: Response, phase: string) {
    phases2.push([await response.clone().text(), phase])
  }
  it('should deduplicate fresh requests', async () => {
    const spy = vi.spyOn(global, 'fetch')
    spy.mockImplementation(
      async (url: string, options?: Parameters<typeof fetch>[1]) =>
        new Response('A', {
          headers: {
            date: todayNoon.toUTCString()
          }
        })
    )
    await expect(
      fetchAndRevalidate('a', undefined, undefined, callback1).then((r) => r.clone().text())
    ).resolves.toEqual('A')
    await expect(
      fetchAndRevalidate('a', undefined, undefined, callback2).then((r) => r.clone().text())
    ).resolves.toEqual('A')
    expect(spy).toHaveBeenCalledTimes(1)
    expect(phases1).toEqual([['A', 'initial']])
    expect(phases2).toEqual([['A', 'initial']])
    await expect(
      fetchAndRevalidate('a', undefined, undefined, callback1).then((r) => r.clone().text())
    ).resolves.toEqual('A')
    expect(phases1).toEqual([
      ['A', 'initial'],
      ['A', 'initial']
    ])
    expect(phases2).toEqual([['A', 'initial']])
    expect(spy).toHaveBeenCalledTimes(1)
    clearFetchCache()
    await expect(
      fetchAndRevalidate('a', undefined, undefined, callback1).then((r) => r.clone().text())
    ).resolves.toEqual('A')
    expect(phases1).toEqual([
      ['A', 'initial'],
      ['A', 'initial'],
      ['A', 'initial']
    ])
    expect(phases2).toEqual([['A', 'initial']])
    await expect(
      fetchAndRevalidate('a', undefined, undefined, callback2).then((r) => r.clone().text())
    ).resolves.toEqual('A')
    expect(phases1).toEqual([
      ['A', 'initial'],
      ['A', 'initial'],
      ['A', 'initial']
    ])
    expect(phases2).toEqual([
      ['A', 'initial'],
      ['A', 'initial']
    ])
    expect(spy).toHaveBeenCalledTimes(2)
  })
  it('should deduplicate failing requests', async () => {
    const spy = vi.spyOn(global, 'fetch')
    spy.mockImplementation(
      async (url: string, options?: Parameters<typeof fetch>[1]) =>
        new Response('A', {
          headers: {
            date: todayNoon.toUTCString()
          },
          status: 400
        })
    )
    expect(() =>
      fetchAndRevalidate('a', undefined, undefined, callback1).then((r) => r.clone().text())
    ).rejects.toEqual(new Error('Fetch failed'))
    expect(() =>
      fetchAndRevalidate('a', undefined, undefined, callback2).then((r) => r.clone().text())
    ).rejects.toEqual(new Error('Fetch failed'))
    expect(spy).toHaveBeenCalledTimes(1)
    expect(phases1).toEqual([])
    expect(phases2).toEqual([])
    expect(() => fetchAndRevalidate('a').then((r) => r.clone().text())).rejects.toEqual(new Error('Fetch failed'))
    clearFetchCache()
    expect(() => fetchAndRevalidate('a').then((r) => r.clone().text())).rejects.toEqual(new Error('Fetch failed'))
    expect(spy).toHaveBeenCalledTimes(2)
    expect(() => fetchAndRevalidate('a').then((r) => r.clone().text())).rejects.toEqual(new Error('Fetch failed'))
    expect(spy).toHaveBeenCalledTimes(2)
    expect(phases1).toEqual([])
    expect(phases2).toEqual([])
  })
  it('should deduplicate cached requests', async () => {
    const spy = vi.spyOn(global, 'fetch')
    spy.mockImplementation(async (url: string, options?: Parameters<typeof fetch>[1]) => {
      if (options?.method == 'HEAD') {
        return new Response('A', {
          headers: {
            date: yesterday.toUTCString()
          }
        })
      } else {
        return new Response('A', {
          headers: {
            date: yesterday.toUTCString()
          }
        })
      }
    })
    await expect(
      fetchAndRevalidate('a', undefined, undefined, callback1).then((r) => r.clone().text())
    ).resolves.toEqual('A')
    await expect(
      fetchAndRevalidate('a', undefined, undefined, callback2).then((r) => r.clone().text())
    ).resolves.toEqual('A')
    expect(spy).toHaveBeenCalledTimes(2)
    expect(phases1).toEqual([['A', 'initial']])
    expect(phases2).toEqual([['A', 'initial']])
    await expect(
      fetchAndRevalidate('a', undefined, undefined, callback1).then((r) => r.clone().text())
    ).resolves.toEqual('A')
    expect(phases1).toEqual([
      ['A', 'initial'],
      ['A', 'initial']
    ])
    expect(phases2).toEqual([['A', 'initial']])
    expect(spy).toHaveBeenCalledTimes(2)
    clearFetchCache()
    await expect(
      fetchAndRevalidate('a', undefined, undefined, callback1).then((r) => r.clone().text())
    ).resolves.toEqual('A')
    expect(phases1).toEqual([
      ['A', 'initial'],
      ['A', 'initial'],
      ['A', 'initial']
    ])
    expect(phases2).toEqual([['A', 'initial']])
    await expect(
      fetchAndRevalidate('a', undefined, undefined, callback2).then((r) => r.clone().text())
    ).resolves.toEqual('A')
    expect(phases1).toEqual([
      ['A', 'initial'],
      ['A', 'initial'],
      ['A', 'initial']
    ])
    expect(phases2).toEqual([
      ['A', 'initial'],
      ['A', 'initial']
    ])
    expect(spy).toHaveBeenCalledTimes(4)
  })
  it('should deduplicate updated requests', async () => {
    const spy = vi.spyOn(global, 'fetch')
    spy.mockImplementation(async (url: string, options?: Parameters<typeof fetch>[1]) => {
      if (options?.method == 'HEAD') {
        return new Response('A', {
          headers: {
            'last-modified': today.toUTCString(),
            date: todayNoon.toUTCString()
          }
        })
      } else if (options?.cache == 'reload') {
        return new Response('B', {
          headers: {
            'last-modified': today.toUTCString(),
            date: today.toUTCString()
          }
        })
      } else {
        return new Response('A', {
          headers: {
            'last-modified': yesterday.toUTCString(),
            date: yesterday.toUTCString()
          }
        })
      }
    })
    await expect(
      fetchAndRevalidate('a', undefined, undefined, callback1).then((r) => r.clone().text())
    ).resolves.toEqual('B')
    await expect(
      fetchAndRevalidate('a', undefined, undefined, callback2).then((r) => r.clone().text())
    ).resolves.toEqual('B')
    expect(spy).toHaveBeenCalledTimes(3)
    expect(phases1).toEqual([
      ['A', 'initial'],
      ['B', 'updated']
    ])
    expect(phases2).toEqual([
      ['A', 'initial'],
      ['B', 'updated']
    ])
    await expect(
      fetchAndRevalidate('a', undefined, undefined, callback1).then((r) => r.clone().text())
    ).resolves.toEqual('B')
    expect(phases1).toEqual([
      ['A', 'initial'],
      ['B', 'updated'],
      ['A', 'initial'],
      ['B', 'updated']
    ])
    expect(phases2).toEqual([
      ['A', 'initial'],
      ['B', 'updated']
    ])
    expect(spy).toHaveBeenCalledTimes(3)
    clearFetchCache()
    await expect(
      fetchAndRevalidate('a', undefined, undefined, callback1).then((r) => r.clone().text())
    ).resolves.toEqual('B')
    expect(phases1).toEqual([
      ['A', 'initial'],
      ['B', 'updated'],
      ['A', 'initial'],
      ['B', 'updated'],
      ['A', 'initial'],
      ['B', 'updated']
    ])
    expect(phases2).toEqual([
      ['A', 'initial'],
      ['B', 'updated']
    ])
    await expect(
      fetchAndRevalidate('a', undefined, undefined, callback2).then((r) => r.clone().text())
    ).resolves.toEqual('B')
    expect(phases1).toEqual([
      ['A', 'initial'],
      ['B', 'updated'],
      ['A', 'initial'],
      ['B', 'updated'],
      ['A', 'initial'],
      ['B', 'updated']
    ])
    expect(phases2).toEqual([
      ['A', 'initial'],
      ['B', 'updated'],
      ['A', 'initial'],
      ['B', 'updated']
    ])
    expect(spy).toHaveBeenCalledTimes(6)
  })
})
