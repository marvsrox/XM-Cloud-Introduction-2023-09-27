import { afterAll, beforeAll, beforeEach, describe, expect, it, vi } from 'vitest'
import { FEAASComponent } from '../src/components/FEAASComponent.js'
import { renderDOMContent } from '../src/dom/rendering.js'
import { clearFetchCache } from '../src/fetch.js'

const earliest = new Date(2000, 1, 1, 0, 0, 0)
const earlier = new Date(2000, 1, 2, 0, 0, 0)
const now = new Date(2000, 1, 2, 12, 0, 0)
describe('Components', () => {
  beforeAll(() => {
    // vi.useFakeTimers()
    vi.setSystemTime(now)
  })
  afterAll(() => {
    // vi.useRealTimers()
  })
  beforeEach(() => {
    document.write()
    clearFetchCache()
  })
  it('should load component using', async () => {
    const spy = vi.spyOn(global, 'fetch')
    spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
      if (url.match('CDN/components/L/C/V/R')) {
        return new Response('TODAY', {
          headers: {
            date: now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      }
    })

    // Fixme change to production component
    document.body.innerHTML =
      '<feaas-component with-stylesheet="false" library="L" cdn="CDN" component="C" version="V" revision="R"></feaas-component>'

    const component = document.body.firstElementChild as FEAASComponent

    await expect(component.whenRendered).resolves.toEqual(component)
    expect(spy).toHaveBeenCalledTimes(1)

    expect(component.innerHTML).toContain('TODAY')
  })

  it('should load component using src attribute shorthand', async () => {
    const spy = vi.spyOn(global, 'fetch')
    spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
      if (url.match('http://a/components/b/c/d/1.html')) {
        return new Response('TODAY', {
          headers: {
            date: now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      }
    })

    // Fixme change to production component
    document.body.innerHTML =
      '<feaas-component with-stylesheet="false" src="http://a/components/b/c/d/1.html"></feaas-component>'

    const component = document.body.firstElementChild as FEAASComponent

    await expect(component.whenRendered).resolves.toEqual(component)
    expect(spy).toHaveBeenCalledTimes(1)

    expect(component.outerHTML).toBe(
      `<feaas-component with-stylesheet="false" src="http://a/components/b/c/d/1.html" cdn="http://a" library="b" component="c" version="d" revision="1" class="-feaas">TODAY</feaas-component>`
    )
  })

  it('should revalidate cached component response', async () => {
    const spy = vi.spyOn(global, 'fetch')
    spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
      if (url.match('CDN/components/L/C/V/R') && options.method != 'HEAD') {
        // 1. Here's cached component
        return new Response('TODAY', {
          headers: {
            date: earlier.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      } else {
        // 2. Is my cached response up to date? Yes.
        return new Response(null, {
          headers: {
            date: now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      }
    })

    // Fixme change to production component
    document.body.innerHTML =
      '<feaas-component with-stylesheet="false" library="L" cdn="CDN" component="C" version="V" revision="R"></feaas-component>'

    const component = document.body.firstElementChild as FEAASComponent

    await expect(component.whenRendered).resolves.toEqual(component)
    expect(spy).toHaveBeenCalledTimes(2)

    expect(component.innerHTML).toContain('TODAY')
  })

  it('should reload component while using stale cache', async () => {
    const spy = vi.spyOn(global, 'fetch')
    spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
      if (options.method != 'HEAD' && options['cache'] != 'reload') {
        // Here's cached component
        return new Response('YESTERDAY', {
          headers: {
            date: earlier.toUTCString(),
            'last-modified': earliest.toUTCString()
          }
        })
      } else if (options.method == 'HEAD') {
        // Is my cached response up to date?
        return new Response(null, {
          headers: {
            date: now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      } else {
        // Up to date version
        return new Response('TODAY', {
          headers: {
            date: now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      }
    })

    // Fixme change to production component
    document.body.innerHTML =
      '<feaas-component with-stylesheet="false" library="L" cdn="CDN" component="C" version="V" revision="R"></feaas-component>'

    const component = document.body.firstElementChild as FEAASComponent
    // Renders cached version initially
    await expect(component.whenRendered).resolves.toEqual(component)
    expect(component.innerHTML).toContain('YESTERDAY')
    expect(spy).toHaveBeenCalledTimes(2)

    // whenLoaded only fires when ensures that up-to-date version is loaded
    await expect(component.whenLoaded).resolves.toBeTruthy()
    expect(spy).toHaveBeenCalledTimes(3)
    expect(component.innerHTML).toContain('TODAY')
  })

  it('should re-fetch component when attributes change', async () => {
    const spy = vi.spyOn(global, 'fetch')
    spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
      if (url.match('CDN/components/L/C2/V/R')) {
        return new Response('C2', {
          headers: {
            date: now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      } else if (url.match('CDN/components/L/C1/V/R')) {
        return new Response('C1', {
          headers: {
            date: now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      }
    })

    // Fixme change to production component
    document.body.innerHTML =
      '<feaas-component with-stylesheet="false" library="L" cdn="CDN" component="C1" version="V" revision="R"></feaas-component>'

    const component = document.body.firstElementChild as FEAASComponent
    await expect(component.whenRendered).resolves.toEqual(component)
    expect(spy).toHaveBeenNthCalledWith(1, 'CDN/components/L/C1/V/R.html', undefined)
    expect(spy).toHaveBeenCalledTimes(1)
    expect(component.innerHTML).toContain('C1')

    component.setAttribute('component', 'C2')
    await expect(component.whenRendered).resolves.toEqual(component)
    expect(spy).toHaveBeenNthCalledWith(2, 'CDN/components/L/C2/V/R.html', undefined)
    expect(spy).toHaveBeenCalledTimes(2)
    expect(component.innerHTML).toContain('C2')
  })
  it('should wait for stylesheet to load', async () => {
    const spy = vi.spyOn(global, 'fetch')
    spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
      if (url.includes('.css')) {
        if (url.match('/styles/L/published.css') && options?.method != 'HEAD' && options?.['cache'] != 'reload') {
          // Serve from cache
          await new Promise((resolve) => setTimeout(resolve, 100))
          return new Response('YESTERDAY {}', {
            headers: {
              date: earlier.toUTCString(),
              'last-modified': earliest.toUTCString()
            }
          })
        } else if (url.match('/styles/L/published.css') && options?.method == 'HEAD') {
          // Validate
          return new Response(null, {
            headers: {
              date: now.toUTCString(),
              'last-modified': earlier.toUTCString()
            }
          })
        } else {
          await new Promise((resolve) => setTimeout(resolve, 200))
          return new Response('TODAY {}', {
            headers: {
              date: now.toUTCString(),
              'last-modified': earlier.toUTCString()
            }
          })
        }
      } else {
        if (options.method != 'HEAD' && options['cache'] != 'reload') {
          // Here's cached component
          return new Response('YESTERDAY', {
            headers: {
              date: earlier.toUTCString(),
              'last-modified': earliest.toUTCString()
            }
          })
        } else if (options.method == 'GET' && options['cache'] == 'reload') {
          // Is my cached response up to date?
          return new Response(null, {
            headers: {
              date: now.toUTCString(),
              'last-modified': earlier.toUTCString()
            }
          })
        } else {
          //  Latest
          await new Promise((resolve) => setTimeout(resolve, 100))
          return new Response('TODAY', {
            headers: {
              date: now.toUTCString(),
              'last-modified': earlier.toUTCString()
            }
          })
        }
      }
    })
    // Fixme change to production component
    document.body.innerHTML = '<feaas-component src="L/C"></feaas-component>'
    const component = document.body.firstElementChild as FEAASComponent
    expect(document.head.querySelector('style')).toBeNull()
    await new Promise((resolve) => setTimeout(resolve, 50))
    const stylesheet = document.head.querySelector('style') as HTMLStyleElement
    expect(stylesheet.innerHTML).toEqual('')
    expect(component.innerHTML).toEqual('')
    // Component will rendered with stale cached stylesheet
    await expect(component.whenRendered).resolves.toEqual(component)
    expect(stylesheet.innerHTML).toEqual('YESTERDAY {}')
    expect(component.innerHTML).toEqual('YESTERDAY')
    // Component will update itself with stale cached stylesheet
    await expect(component.whenLoaded).resolves.toEqual('TODAY')
    expect(stylesheet.innerHTML).toEqual('YESTERDAY {}')
    expect(component.innerHTML).toEqual('TODAY')
    await new Promise((resolve) => setTimeout(resolve, 100))
    // Stylesheet will update later
    expect(stylesheet.innerHTML).toEqual('TODAY {}')
  })

  it('render without data', () => {
    const component = new FEAASComponent()
    const div = document.createElement('div')
    div.appendChild(component)
    document.body.appendChild(div)
    renderDOMContent(component, `<section class="-theme--abc test"></section><section class="-theme--cde"></section>`)
    expect(div.innerHTML).toEqual(
      `<feaas-component class="-feaas"><section class="-theme--abc test"></section><section class="-theme--cde"></section></feaas-component>`
    )
    component.className = '-theme--override test2'
    renderDOMContent(component, `<section class="-theme--abc test"></section><section class="-theme--cde"></section>`)
    expect(div.innerHTML).toEqual(
      `<feaas-component class="-theme--override test2 -feaas"><section class="test"></section><section class=""></section></feaas-component>`
    )
  })
})
