import { describe, it, assert, beforeAll, expect } from 'vitest'
import { FEAASBase, ReactPayload } from '../src/headless.js'
import { JSDOM } from 'jsdom'

describe('React', function () {
  describe('Error boundary', () => {
    class FEAASErrorTest extends FEAASBase<{ throwAt: string }> {
      static observedAttributes = ['test']

      log() {}

      getProps() {
        this.fail('get-props')
        return {
          throw: this.getAttribute('throw') ?? null,
          test: this.getAttribute('test')
        }
      }

      mount() {
        if (this.fail('before-mount', true)) return
        super.mount()
        if (this.fail('after-mount', true)) {
          super.unmount()
        }
      }

      unmount() {
        this.fail('before-unmount', true)
        super.unmount()
        this.fail('after-unmount', true)
      }

      connectedCallback(): void {
        super.connectedCallback()
      }

      load() {
        this.fail('before-load')
        return Promise.all([import('react'), import('react-dom'), import('react-dom/client')]).then(
          ([React, ReactDOM, ReactDOMClient]) => {
            this.fail('after-load')
            return { React, ReactDOM, ReactDOMClient }
          }
        )
      }

      render({}: typeof this.props, { React }: ReactPayload) {
        const error = console.error
        console.error = () => {}
        requestAnimationFrame(() => (console.error = error))
        this.fail('render')
        return <div>{1}</div>
      }

      fail(type: string, soft = false) {
        if (
          (this.getAttribute('throw') == 'initial-' + type && !this.initialized) ||
          (this.getAttribute('throw') == 'subsequent-' + type && this.initialized)
        ) {
          const e = new Error(this.getAttribute('throw'))
          if (soft) {
            this.onError(e)
            return true
          } else {
            throw e
          }
        }
      }
    }
    FEAASErrorTest.register('feaas-test-error-boundary')
    const errors = [] as Error[]
    document.addEventListener('feaasError', (e: CustomEvent<Error>) => {
      errors.push(e.detail)
      //e.preventDefault()
    })

    describe('during initialization', () => {
      it('should render successfuly', async () => {
        document.write('<feaas-test-error-boundary></feaas-test-error-boundary>')
        await (document.body.firstElementChild as FEAASErrorTest).whenRendered
        expect(document.body.innerHTML).toEqual(`<feaas-test-error-boundary><div>1</div></feaas-test-error-boundary>`)
      })
      async function failOn(errorType: string) {
        try {
          document.write(`<feaas-test-error-boundary throw="${errorType}"></feaas-test-error-boundary>`)
        } catch (e) {}
        const component = document.body.firstElementChild as FEAASErrorTest

        // Initialization promise is rejected
        await Promise.all([
          expect(() => component.whenRendered).rejects.toEqual(new Error(errorType)),
          expect(() => component.whenLoaded).rejects.toEqual(new Error(errorType))
        ])

        // feaasEvent is dispatched and bubbled to dom
        expect(errors.splice(0)).toEqual([new Error(errorType)])

        // Component is auto-unmounted (but not ejected from dom)
        expect(component.connected).toBe(false)
        expect(document.body.innerHTML).toEqual(
          `<feaas-test-error-boundary throw="${errorType}"></feaas-test-error-boundary>`
        )
      }
      it('handles error on get-props', () => failOn('initial-get-props'))
      it('handles error on before mount', () => failOn('initial-before-mount'))
      it('handles error on after mount', () => failOn('initial-after-mount'))
      it('handles error on before load', () => failOn('initial-before-load'))
      it('handles error on after load', () => failOn('initial-after-load'))
    })
    describe('during first render', () => {
      it('should render successfuly', async () => {
        document.write('<feaas-test-error-boundary></feaas-test-error-boundary>')
        await (document.body.firstElementChild as FEAASErrorTest).whenRendered
        expect(document.body.innerHTML).toEqual(`<feaas-test-error-boundary><div>1</div></feaas-test-error-boundary>`)
      })
      async function failOn(errorType: string) {
        try {
          document.write(`<feaas-test-error-boundary throw="${errorType}"></feaas-test-error-boundary>`)
        } catch (e) {}
        const component = document.body.firstElementChild as FEAASErrorTest

        // Initialization promise is rejected
        await Promise.all([
          expect(() => component.whenRendered).rejects.toEqual(new Error(errorType)),
          expect(component.whenLoaded).resolves.toBeTruthy()
        ])

        // feaasEvent is dispatched and bubbled to dom
        expect(errors.splice(0)).toEqual([new Error(errorType)])

        // Component is auto-unmounted (but not ejected from dom)
        expect(component.connected).toBe(false)
        expect(document.body.innerHTML).toEqual(
          `<feaas-test-error-boundary throw="${errorType}"></feaas-test-error-boundary>`
        )
      }
      it('handles error on render', () => failOn('initial-render'))
    })
    describe('subsequently', () => {
      it('should render successfuly', async () => {
        document.write('<feaas-test-error-boundary></feaas-test-error-boundary>')
        const component = document.body.firstElementChild as FEAASErrorTest
        await expect(component.whenLoaded).resolves.toBeTruthy()
        component.setAttribute('test', 'lol')
        await expect(component.whenRendered).resolves.toEqual(component)
        expect(document.body.innerHTML).toEqual(
          `<feaas-test-error-boundary test="lol"><div>1</div></feaas-test-error-boundary>`
        )
      })
      async function failOn(errorType: string, callback: (component: FEAASErrorTest) => void) {
        document.write(`<feaas-test-error-boundary throw="${errorType}"></feaas-test-error-boundary>`)
        const component = document.body.firstElementChild as FEAASErrorTest

        // Initialization promise is resolved
        await expect(component.whenLoaded).resolves.toBeTruthy()
        await expect(component.whenRendered).resolves.toBeTruthy()

        // No errors were thrown during initialization
        expect(errors.splice(0)).toEqual([])

        // Component has rendered
        expect(document.body.innerHTML).toEqual(
          `<feaas-test-error-boundary throw="${errorType}"><div>1</div></feaas-test-error-boundary>`
        )

        // Execute logic after initialization
        callback(component)
        await expect(() => component.whenRendered).rejects.toEqual(new Error(errorType))

        // feaasEvent is dispatched and bubbled to dom
        expect(errors.splice(0)).toEqual([new Error(errorType)])

        // Component is auto-unmounted (but not ejected from dom)
        expect(component.connected).toBe(false)
      }
      it('handles error on change', async () => {
        await failOn('subsequent-get-props', (component) => {
          component.setAttribute('test', 'lol')
        })
        expect(document.body.innerHTML).toEqual(
          `<feaas-test-error-boundary throw="subsequent-get-props" test="lol"><div>1</div></feaas-test-error-boundary>`
        )
      })
      it('handles error on render', async () => {
        await failOn('subsequent-render', (component) => {
          component.setAttribute('test', 'lol')
        })
        expect(document.body.innerHTML).toEqual(
          `<feaas-test-error-boundary throw="subsequent-render" test="lol"></feaas-test-error-boundary>`
        )
      })
    })
  })
})
