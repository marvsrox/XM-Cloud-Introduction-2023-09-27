import { ControlledPromise } from './utils/promise.js';
/**
 * Utility to cache-bust static files. It relies on reading Date header to detect cached response, so it requires CORS
 * settings to be set.
 *
 * It accepts validator function that determines if response is usable. If response was pulled from cache and is valid,
 * the optional callback function is fired right away. Then HEAD request is made bypassing the cache, to see if the
 * response has an newer Last-Modified header. In case it does and it passes validation, third request is fired that
 * actually fetches the new content and callback is invoked the second time.
 *
 * It works as promise, but also accepts callback to use cached blobs mid-flight and have access to headers. Any network
 * errors will not be caught. Function throws when unable to fetch valid response.
 */
declare const phases: readonly ["initial", "check", "updated"];
export type ValidatableRequestPhase = typeof phases[number];
export type FetchCache = Record<string, FetchCacheRequest>;
export interface ValidatableRequest {
    url: Parameters<typeof fetch>[0];
    options?: Parameters<typeof fetch>[1];
    validator?: (resposne: Response) => boolean;
    callback?: (response: Response, status: ValidatableRequestPhase, isCached: boolean) => any;
    isCached?: boolean;
    response?: Response;
    cache?: FetchCache;
}
export type FetchCacheRequest = {
    phase: ValidatableRequestPhase;
    initial: ControlledPromise<Response>;
    check: ControlledPromise<Response>;
    updated: ControlledPromise<Response>;
    final: ControlledPromise<Response>;
};
export declare var fetchCache: Record<string, FetchCacheRequest>;
export declare function clearFetchCache(): void;
export declare function fetchAndRevalidate(url: ValidatableRequest['url'], options?: ValidatableRequest['options'], validator?: ValidatableRequest['validator'], callback?: ValidatableRequest['callback'], cache?: FetchCache): Promise<Response>;
export declare function getFetchCache(url: Parameters<typeof fetch>[0], dontCreate?: boolean): FetchCacheRequest;
export declare function fetchWithCacheAwareness({ url, options, validator, callback, cache }: ValidatableRequest, phase?: ValidatableRequestPhase): Promise<{
    url: RequestInfo | URL;
    options: RequestInit;
    isCached: boolean;
    response: Response;
    validator: (resposne: Response) => boolean;
    callback: (response: Response, status: "initial" | "check" | "updated", isCached: boolean) => any;
    cache: FetchCache;
}>;
export declare function fetchToValidateCache(request: ValidatableRequest & Required<Pick<ValidatableRequest, 'response'>>): Promise<ValidatableRequest & Required<Pick<ValidatableRequest, "response">>>;
export declare function fetchBypassingCache(request: ValidatableRequest): Promise<{
    url: RequestInfo | URL;
    options: RequestInit;
    isCached: boolean;
    response: Response;
    validator: (resposne: Response) => boolean;
    callback: (response: Response, status: "initial" | "check" | "updated", isCached: boolean) => any;
    cache: FetchCache;
}>;
export {};
//# sourceMappingURL=fetch.d.ts.map