import type { ReactElement, ReactNode } from 'react';
import type ReactDOMClient from 'react-dom/client';
import type ReactDOM from 'react-dom';
import type React from 'react';
import { ControlledPromise } from '../utils/promise.js';
export type OptionalExcept<T, K extends keyof T> = Pick<T, K> & Partial<Omit<T, K>>;
declare var WebComponent: {
    new (): HTMLElement;
    prototype: HTMLElement;
};
export interface ReactPayload {
    React: typeof React;
    ReactDOM: typeof ReactDOM;
    ReactDOMClient: typeof ReactDOMClient;
}
/**
 * FEAASBase is a superclass for FEAAS components with optional react support.
 *
 * Initialization lifecycle:
 *
 * - `set(props)`
 * - `load() => payload`
 * - `onLoad?(payload)`
 * - `update()`
 * - `render(payload, props)`
 * - `whenRendered`
 * - - / If needs to reload, e.g. bypass cache /
 * - - `onLoad(newPayload) `
 * - - `whenRendered`
 * - `whenLoaded`
 */
export declare class FEAASBase<Props = any, Payload = any> extends WebComponent {
    static observedAttributes: string[];
    defaultProps: Partial<Props>;
    /** Return attributes as parsed values */
    getProps(context?: HTMLElement): any;
    /** Properties parsed in current tick */
    props: Props;
    overrides: Props;
    /** Timer until next tick */
    nextRender: number;
    /** Is/was component in the dom? */
    connected: boolean;
    refs: Record<string, FEAASBase>;
    descendants: FEAASBase[];
    /** Result of lazy loading */
    payload: Payload;
    whenLoaded: ControlledPromise<Payload>;
    constructor();
    /** Attaches shadow root if getShadowRootOptions any settings, or uses element itself */
    getRoot(): FEAASBase | HTMLElement | ShadowRoot;
    /** Attribute changes trigger props parsing and schedules re-rendering */
    attributeChangedCallback(name: string, oldValue: string, newValue: string): void;
    /** Components parses its attributes when connected, and schedules rendeirng */
    connectedCallback(): void;
    disconnectedCallback(): void;
    /**
     * Web components are initialized depth-first, making child elements render before its parents. This could here
     * attempts to avoid this and inverts the initialization logic, so that children are initialized in the context of its
     * already-initialized parents.
     *
     * FEAAS components dispatch `feaasMount` event that allows components to store references to each other. In addition
     * it allows external scripts to listen for initialization of FEAAS components
     */
    mount(): void;
    log(...args: any): void;
    /** Nothing special happens on unmount, except setting a flag */
    unmount(): void;
    getParent(onlyFeaas?: boolean): HTMLElement;
    getElements(root?: HTMLElement | ShadowRoot, onlyFeaas?: boolean): HTMLElement[];
    /** Catch-all event handler that dispatches events to callback */
    handleEvent(event: Event): void;
    /** Act on children element being removed */
    unnestedCallback(target: FEAASBase): void;
    /** Act on children element being added */
    nestedCallback(target: FEAASBase): boolean | void;
    getComponentName(): string;
    /**
     * Check if lazy component is ready to be loaded. For example a component may stay unloaded unless certain attributes
     * are set
     */
    isReadyToLoad(): boolean;
    /** Generic error handler */
    onError(error: Error, where?: string, handled?: boolean): boolean;
    shouldUpdateOnLoad(): boolean;
    onLoad: (payload: Payload) => void;
    /** Load lazy component & render */
    advance(): Promise<void>;
    flush(): void;
    /** Invoke preloading logic that needs to finish before component can render */
    load(): Promise<any>;
    /**
     * Component-specific logic that updates the DOM. Default render implementation assume react rendering, in that case
     * the component needs to provide React & ReactDOM references in its payload. Web component redefine its render to not
     * use react at all
     */
    update(): any;
    invokeReactRendering(): ReactNode;
    reactWrapper: React.FunctionComponent;
    reactErrorBoundary: new (...args: any) => React.Component<{
        children: any;
        slot: string;
    }, {
        error: Error;
    }>;
    reactRoot: ReactDOMClient.Root;
    getReactErrorBoundary(target?: FEAASBase, displayName?: string): (new (...args: any) => React.Component<{
        children: any;
        slot: string;
    }, {
        error: Error;
    }, any>) | {
        new (props: {
            children: any;
            slot: string;
        } | Readonly<{
            children: any;
            slot: string;
        }>): {
            state: {
                error: Error;
            };
            componentDidCatch(error: Error, errorInfo: any): void;
            render(): any;
            context: unknown;
            setState<K extends "error">(state: {
                error: Error;
            } | ((prevState: Readonly<{
                error: Error;
            }>, props: Readonly<{
                children: any;
                slot: string;
            }>) => {
                error: Error;
            } | Pick<{
                error: Error;
            }, K>) | Pick<{
                error: Error;
            }, K>, callback?: () => void): void;
            forceUpdate(callback?: () => void): void;
            readonly props: Readonly<{
                children: any;
                slot: string;
            }>;
            refs: {
                [key: string]: React.ReactInstance;
            };
            componentDidMount?(): void;
            shouldComponentUpdate?(nextProps: Readonly<{
                children: any;
                slot: string;
            }>, nextState: Readonly<{
                error: Error;
            }>, nextContext: any): boolean;
            componentWillUnmount?(): void;
            getSnapshotBeforeUpdate?(prevProps: Readonly<{
                children: any;
                slot: string;
            }>, prevState: Readonly<{
                error: Error;
            }>): any;
            componentDidUpdate?(prevProps: Readonly<{
                children: any;
                slot: string;
            }>, prevState: Readonly<{
                error: Error;
            }>, snapshot?: any): void;
            componentWillMount?(): void;
            UNSAFE_componentWillMount?(): void;
            componentWillReceiveProps?(nextProps: Readonly<{
                children: any;
                slot: string;
            }>, nextContext: any): void;
            UNSAFE_componentWillReceiveProps?(nextProps: Readonly<{
                children: any;
                slot: string;
            }>, nextContext: any): void;
            componentWillUpdate?(nextProps: Readonly<{
                children: any;
                slot: string;
            }>, nextState: Readonly<{
                error: Error;
            }>, nextContext: any): void;
            UNSAFE_componentWillUpdate?(nextProps: Readonly<{
                children: any;
                slot: string;
            }>, nextState: Readonly<{
                error: Error;
            }>, nextContext: any): void;
        };
        new (props: {
            children: any;
            slot: string;
        }, context: any): {
            state: {
                error: Error;
            };
            componentDidCatch(error: Error, errorInfo: any): void;
            render(): any;
            context: unknown;
            setState<K extends "error">(state: {
                error: Error;
            } | ((prevState: Readonly<{
                error: Error;
            }>, props: Readonly<{
                children: any;
                slot: string;
            }>) => {
                error: Error;
            } | Pick<{
                error: Error;
            }, K>) | Pick<{
                error: Error;
            }, K>, callback?: () => void): void;
            forceUpdate(callback?: () => void): void;
            readonly props: Readonly<{
                children: any;
                slot: string;
            }>;
            refs: {
                [key: string]: React.ReactInstance;
            };
            componentDidMount?(): void;
            shouldComponentUpdate?(nextProps: Readonly<{
                children: any;
                slot: string;
            }>, nextState: Readonly<{
                error: Error;
            }>, nextContext: any): boolean;
            componentWillUnmount?(): void;
            getSnapshotBeforeUpdate?(prevProps: Readonly<{
                children: any;
                slot: string;
            }>, prevState: Readonly<{
                error: Error;
            }>): any;
            componentDidUpdate?(prevProps: Readonly<{
                children: any;
                slot: string;
            }>, prevState: Readonly<{
                error: Error;
            }>, snapshot?: any): void;
            componentWillMount?(): void;
            UNSAFE_componentWillMount?(): void;
            componentWillReceiveProps?(nextProps: Readonly<{
                children: any;
                slot: string;
            }>, nextContext: any): void;
            UNSAFE_componentWillReceiveProps?(nextProps: Readonly<{
                children: any;
                slot: string;
            }>, nextContext: any): void;
            componentWillUpdate?(nextProps: Readonly<{
                children: any;
                slot: string;
            }>, nextState: Readonly<{
                error: Error;
            }>, nextContext: any): void;
            UNSAFE_componentWillUpdate?(nextProps: Readonly<{
                children: any;
                slot: string;
            }>, nextState: Readonly<{
                error: Error;
            }>, nextContext: any): void;
        };
        getDerivedStateFromError(error: Error): {
            error: Error;
        };
        contextType?: React.Context<any>;
    };
    getReactElement(target?: FEAASBase, props?: any): JSX.Element;
    getReactWrapper(target?: FEAASBase, displayName?: string): React.FunctionComponent<{}>;
    uid: string;
    getUID(): string;
    forceUpdateReact: (node?: ReactNode) => void;
    /**
     * Render method that is pretty much the same as React Functional component, but with extra second argument for
     * payload (usually result of import, it is expected to have React in scope).
     */
    render?(props: React.PropsWithChildren<Props>, payload: Payload): ReactNode | ReactElement;
    useShadowRoot: boolean;
    getShadowRoot(): ShadowRoot;
    getReactRootElement(): HTMLElement | ShadowRoot;
    /** Set props and return values on new next tick */
    set(overrides?: Partial<Props>): this;
    import(path: string): Promise<Payload>;
    /** Schedule rendering on next tick, to batch multiple attribute changes */
    initialized: boolean;
    whenRendered: ControlledPromise<this>;
    scheduleRender(): void;
    formatURL(src: string, hostname: string): string;
    getContextAttribute(name: string, element?: this): string;
    static register(tagName: string, win?: Window): void;
}
export { FEAASBase as Base };
//# sourceMappingURL=FEAASBase.d.ts.map