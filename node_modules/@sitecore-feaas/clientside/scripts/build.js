import path from 'path'
import * as esbuild from 'esbuild'
import replace from 'esbuild-plugin-replace-regex'
import * as url from 'url'
import fs from 'fs'
const __filename = url.fileURLToPath(import.meta.url)
const __dirname = url.fileURLToPath(new URL('.', import.meta.url))

// Same character length to avoid breaking source map
const MagicImportComment = ' /*@vite-ignore*/ /* webpackIgnore: true */ '
const MagicImportPlacehl = '_MAGIC_IMPORT_COMMENTS_ESBUILD_WORKAROUND_||'

function compile({ input, output, ...step }) {
  return esbuild.build({
    entryPoints: [path.resolve(__dirname, '../' + input)],
    outfile: path.resolve(__dirname, '../' + output),
    bundle: true,
    write: false,
    external: ['node:crypto', 'node-fetch', '_MAGIC_IMPORT_COMMENTS_ESBUILD_WORKAROUND__', 'react', 'react-dom', 'vm'],

    ...step,

    minify: true,
    logOverride: {
      'unsupported-dynamic-import': 'silent',
      'unsupported-require-import': 'silent'
    },
    logLevel: 'debug',
    sourcemap: 'linked',

    plugins: [
      replace({
        filter: /.[mc]?js$/,
        patterns: [
          // HACK: ESbuild removes comments, but we need to have magic comments in order for
          // webpack consuming our modules to not choke up. This plugin runs before minification,
          // so comments unfortunately still get removed. Instead we add something that of the same length
          // that will not be removed by minifier, and then replace it to comment as post-process step.
          // Sourcemap will keep working if the length is the same
          // import(_XXXXXXXXXXXXXXX||, ...)
          [/import\((?![^\n]+{\s*\n)/g, 'import(' + MagicImportPlacehl]
        ]
      }),
      {
        name: 'magic-comments',

        setup(build) {
          // to post-process files we need to disable write, and then write manually
          build.onEnd((result) => {
            if (!result?.outputFiles) return
            result.outputFiles.map((f) => {
              if (f.path.match(/\.[mc]?[j]sx?$/))
                f.contents = Buffer.from(
                  f.text.replace(new RegExp(MagicImportPlacehl.replace(/\|/g, '\\|'), 'g'), MagicImportComment)
                )
              return fs.promises.mkdir(path.dirname(f.path), { recursive: true }).then(() => {
                return fs.promises.writeFile(f.path, f.contents)
              })
            })
          })
        }
      }
    ]
  })
}
;[
  { input: 'build/ui/index.js', output: 'dist/node/index.cjs', platform: 'node', format: 'cjs' },
  { input: 'build/ui/index.js', output: 'dist/node/index.esm.js', platform: 'node', format: 'esm' },
  { input: 'build/ui/react.js', output: 'dist/node/react.cjs', platform: 'node', format: 'cjs' },
  { input: 'build/ui/react.js', output: 'dist/node/react.esm.js', platform: 'node', format: 'esm' },
  { input: 'build/headless.js', output: 'dist/node/headless.cjs', platform: 'node', format: 'cjs' },
  { input: 'build/headless.js', output: 'dist/node/headless.esm.js', platform: 'node', format: 'esm' },
  { input: 'build/ui/index.js', output: 'dist/browser/index.cjs', platform: 'browser', format: 'cjs' },
  { input: 'build/ui/index.js', output: 'dist/browser/index.esm.js', platform: 'browser', format: 'esm' },
  { input: 'build/ui/react.js', output: 'dist/browser/react.cjs', platform: 'browser', format: 'cjs' },
  { input: 'build/ui/react.js', output: 'dist/browser/react.esm.js', platform: 'browser', format: 'esm' },
  { input: 'build/headless.js', output: 'dist/browser/headless.cjs', platform: 'browser', format: 'cjs' },
  { input: 'build/headless.js', output: 'dist/browser/headless.esm.js', platform: 'browser', format: 'esm' },

  // backward compatability with pre-export maps
  { input: 'build/ui/react.js', output: 'react.js', platform: 'browser', format: 'cjs' },
  { input: 'build/headless.js', output: 'headless.js', platform: 'node', format: 'cjs' },
  { input: 'build/ui/react.js', output: 'react.cjs', platform: 'browser', format: 'cjs' },
  { input: 'build/headless.js', output: 'headless.cjs', platform: 'node', format: 'cjs' }
].map((step) => {
  return compile(step)
})
