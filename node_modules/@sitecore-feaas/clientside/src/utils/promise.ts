export type ControlledPromise<T> = Promise<T> & {
  resolve: (...args: any) => void
  reject: (e: Error) => void
  restart: () => ControlledPromise<T>
  first: ControlledPromise<T>
}

export function ControlledPromise<T>(onSuccess?: (result: T) => void, onFailure = (e: Error) => {}) {
  var first: ControlledPromise<T>
  const restart = () => {
    var resolve: (...args: any) => void
    var reject: (e: Error) => void
    const promise = new Promise<T>((success, failure) => {
      resolve = (value: T) => {
        onSuccess?.(value)
        success(value)
      }
      reject = failure
    })
    var controlled: ControlledPromise<T> = Object.assign(promise, {
      resolve,
      reject,
      restart,
      first
    })
    first = controlled

    // Avoid unhandled rejection
    controlled.catch(onFailure)

    return controlled
  }
  return restart()
}
