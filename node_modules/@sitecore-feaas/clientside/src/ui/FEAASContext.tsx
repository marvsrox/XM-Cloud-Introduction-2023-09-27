import type * as FEAASContextImports from '@sitecore-feaas/frontend/context'
import type { AuthModel } from '@sitecore-feaas/sdk'
import { FEAASBase, OptionalExcept } from '../components/FEAASBase.js'

export function FEAASContextProps(element: HTMLElement = this) {
  return {
    library: element?.getAttribute('library') as string,
    src: element?.getAttribute('src') ?? '/context.js',
    frontend: element?.getAttribute('frontend') ?? 'https://components.sitecoreclud.io',
    backend: element?.getAttribute('backend') ?? 'https://components.sitecoreclud.io/api',
    cdn: element?.getAttribute('cdn') ?? 'https://feaas.blob.core.windows.net',
    auth: null as Partial<AuthModel>,
    isolate: element?.getAttribute('isolate') == null || element?.getAttribute('isolate') == 'true'
  }
}
export type FEAASContextProps = ReturnType<typeof FEAASContextProps>

/**
 * Context provides shared parameters and react providers for its nested elements. It loads lazily once any of its
 * nested components load. Just placing it on the page without any consumers does not impose any overhead.
 */
export class FEAASContext extends FEAASBase<FEAASContextProps, typeof FEAASContextImports> {
  static observedAttributes = ['library', 'component', 'version', 'revision', 'hostname', 'template']
  getProps() {
    return FEAASContextProps(this)
  }

  defaultProps = {
    isolate: true
  } as Partial<FEAASContextProps>

  load() {
    return this.import(this.formatURL(this.props.src, this.props.frontend))
  }

  isReadyToLoad() {
    console.log('Is ready?', this.props, super.isReadyToLoad() && this.props.library != null)
    return super.isReadyToLoad() && this.props.library != null
  }

  // Remove global styles
  getTheme(theme: FEAASContextImports.Chakra.Theme): FEAASContextImports.Chakra.Theme {
    return theme
  }

  getRoot(): HTMLElement | FEAASBase<any, any> | ShadowRoot {
    if (this.getAttribute('isolate') === 'false') return this
    return this.shadowRoot || this.attachShadow({ mode: 'open' })
  }

  reactRootElement: HTMLDivElement
  getReactRootElement() {
    //if (!this.props.isolate) return this.getRoot()
    if (!this.reactRootElement) {
      this.reactRootElement = document.createElement('div')
      this.getRoot().appendChild(this.reactRootElement)
    }
    return this.reactRootElement
  }

  /** Pull in children FEAAS react elements into the shadow DOM so they receieve the styles */
  connectedCallback(): void {
    Array.from(this.children).forEach((child) => {
      this.getRoot().appendChild(child)
    })
    super.connectedCallback()
  }

  onStatusChange = (status: string) => {
    if (status == 'ready') {
      this.dispatchEvent(new Event('feaasReady', { bubbles: true, composed: true }))
    }
  }

  render(
    { children, library }: React.PropsWithChildren<FEAASContextProps>,
    { AppContext, Chakra: { Button, Tooltip }, React }: typeof this.payload
  ) {
    const portalProps = {
      containerRef: { current: this.getRoot() as HTMLElement }
    }
    Tooltip.defaultProps = {
      hasArrow: true,
      placement: 'top',
      portalProps
    }
    return (
      <AppContext
        backend={this.props.backend}
        libraryId={this.props.library}
        container={this.getRoot()}
        auth={this.props.auth}
        getTheme={this.getTheme}
        onStatusChange={this.onStatusChange}
        modalProps={{
          portalProps
        }}
        chakraProps={{
          cssVarsRoot: ':host',
          resetCSS: true,
          toastOptions: {
            portalProps
          }
        }}
      >
        {children}
      </AppContext>
    )
  }
}

declare global {
  namespace JSX {
    interface IntrinsicElements {
      'feaas-context': OptionalExcept<FEAASContextProps, 'library'>
    }
  }
}

FEAASContext.register('feaas-context')
