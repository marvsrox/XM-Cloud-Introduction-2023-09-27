/** Lightweight DOM parser and serializer to use in server environments */
import { renderDOMElement } from './rendering.js';
class HTMLNode {
    constructor(nodeName, nodeType = 1, textContent) {
        this.ownerDocument = {
            createElement(name) {
                return new HTMLNode(name);
            }
        };
        this.nodeName = nodeName;
        this.nodeType = nodeType;
        this.textContent = textContent;
        this.attributes = [];
        this.childNodes = [];
    }
    setAttribute(name, value) {
        const attr = this.attributes.find((attr) => attr.name === name);
        if (attr) {
            attr.value = value;
        }
        else {
            this.attributes.push({ name, value });
        }
    }
    getAttribute(name) {
        const attr = this.attributes.find((attr) => attr.name === name);
        return attr ? attr.value : undefined;
    }
    insertBefore(newNode, referenceNode) {
        newNode.parentNode = this;
        if (referenceNode === null) {
            this.childNodes.push(newNode);
        }
        else {
            const index = this.childNodes.indexOf(referenceNode);
            if (index !== -1) {
                this.childNodes.splice(index, 0, newNode);
            }
        }
    }
    removeAttribute(attrName) {
        const index = this.attributes.findIndex((attr) => attr.name === attrName);
        if (index !== -1) {
            this.attributes.splice(index, 1);
        }
    }
    appendChild(newNode) {
        newNode.parentNode = this;
        this.childNodes.push(newNode);
    }
    get tagName() {
        var _a;
        return (_a = this.nodeName) === null || _a === void 0 ? void 0 : _a.toUpperCase();
    }
    get innerHTML() {
        return serializeHTML(this.childNodes);
    }
    set innerHTML(html) {
        this.childNodes = parseHTML(String(html !== null && html !== void 0 ? html : ''));
    }
    get outerHTML() {
        return serializeHTML([this]);
    }
    closest(selector) {
        let currentNode = this;
        while (currentNode) {
            if (selectorMatchesNode(selector, currentNode)) {
                return currentNode;
            }
            currentNode = currentNode.parentNode;
        }
        return null;
    }
    querySelectorAll(selector) {
        const selectors = selector.split(/\s*,\s*/);
        const results = [];
        const checkNode = (node) => {
            for (const sel of selectors) {
                if (selectorMatchesNode(sel, node)) {
                    results.push(node);
                    break;
                }
            }
            for (const child of node.childNodes) {
                checkNode(child);
            }
        };
        for (const child of this.childNodes) {
            checkNode(child);
        }
        return results;
    }
    querySelector(selector) {
        return this.querySelectorAll(selector)[0];
    }
    findSibling(step, elementTypeOnly) {
        if (!this.parentNode)
            return null;
        const siblings = this.parentNode.childNodes;
        const index = siblings.indexOf(this);
        if (index === -1)
            return null;
        for (let i = index + step; i >= 0 && i < siblings.length; i += step) {
            const sibling = siblings[i];
            if (!elementTypeOnly || sibling.nodeType === 1) {
                return sibling;
            }
        }
        return null;
    }
    removeChild(child) {
        const index = this.childNodes.indexOf(child);
        if (index === -1)
            return;
        this.childNodes.splice(index, 1);
        child.parentNode = undefined;
        return child;
    }
    get previousSibling() {
        return this.findSibling(-1);
    }
    get nextSibling() {
        return this.findSibling(1);
    }
    get previousElementSibling() {
        return this.findSibling(-1, true);
    }
    get nextElementSibling() {
        return this.findSibling(1, true);
    }
    cloneNode(deep = false) {
        const clonedNode = new HTMLNode(this.nodeName, this.nodeType);
        clonedNode.attributes = JSON.parse(JSON.stringify(this.attributes));
        if (this.textContent) {
            clonedNode.textContent = this.textContent;
        }
        if (deep) {
            for (const childNode of this.childNodes) {
                const clonedChild = childNode.cloneNode(true);
                clonedNode.appendChild(clonedChild);
            }
        }
        return clonedNode;
    }
    get parentElement() {
        var _a;
        return ((_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.nodeType) == 1 ? this.parentNode : null;
    }
}
function selectorMatchesNode(selector, node) {
    const simpleSelectors = selector.match(/([.#]?[\w-]+|\[([\w-]+)(="([^"]*)")?\])/g);
    if (!simpleSelectors) {
        return false;
    }
    for (const simpleSelector of simpleSelectors) {
        if (simpleSelector.startsWith('#')) {
            if (node.getAttribute('id') !== simpleSelector.slice(1)) {
                return false;
            }
        }
        else if (simpleSelector.startsWith('.')) {
            const classNames = (node.getAttribute('class') || '').split(' ');
            if (!classNames.includes(simpleSelector.slice(1))) {
                return false;
            }
        }
        else if (simpleSelector.startsWith('[')) {
            const attrSelectorMatch = simpleSelector.match(/^\[([\w-]+)(="([^"]*)")?\]$/);
            if (attrSelectorMatch) {
                const attrName = attrSelectorMatch[1];
                const attrValue = attrSelectorMatch[3];
                const actualValue = node.getAttribute(attrName);
                if (typeof attrValue === 'undefined') {
                    if (actualValue === undefined) {
                        return false;
                    }
                }
                else {
                    if (actualValue !== attrValue) {
                        return false;
                    }
                }
            }
            else {
                return false;
            }
        }
        else {
            if (node.nodeName !== simpleSelector) {
                return false;
            }
        }
    }
    return true;
}
export function parseHTML(html) {
    var _a;
    const nodes = [];
    const stack = [];
    while (html) {
        const openTagMatch = html.match(/^<([\w-]+)(\s[^>]*)?>/);
        const closingTagMatch = html.match(/^<\/([\w-]+)>/);
        if (openTagMatch) {
            const nodeName = openTagMatch[1];
            const attrsStr = openTagMatch[2] || '';
            const attrs = ((_a = attrsStr.match(/([\w-]+)(="([^"]*)")?/g)) === null || _a === void 0 ? void 0 : _a.map((attr) => {
                const [_, name, , value] = attr.match(/([\w-]+)(="([^"]*)")?/);
                return { name, value: unescapeHTML(value || '') };
            })) || [];
            const node = new HTMLNode(nodeName, 1);
            node.attributes = attrs;
            if (stack.length > 0) {
                const parentNode = stack[stack.length - 1];
                parentNode.childNodes.push(node);
                node.parentNode = parentNode;
            }
            else {
                nodes.push(node);
            }
            stack.push(node);
            html = html.slice(openTagMatch[0].length);
        }
        else if (closingTagMatch) {
            stack.pop();
            html = html.slice(closingTagMatch[0].length);
        }
        else {
            const textEnd = html.indexOf('<');
            const textContent = html.slice(0, textEnd !== -1 ? textEnd : undefined);
            const textNode = new HTMLNode('#text', 3);
            textNode.textContent = textContent;
            if (stack.length > 0) {
                const parentNode = stack[stack.length - 1];
                parentNode.childNodes.push(textNode);
                textNode.parentNode = parentNode;
            }
            else {
                nodes.push(textNode);
            }
            html = html.slice(textContent.length);
        }
    }
    return nodes;
}
export function escapeHTML(input) {
    return input
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;');
}
function unescapeHTML(input) {
    return input
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&quot;/g, '"')
        .replace(/&#x27;/g, "'");
}
export function serializeHTML(nodes) {
    return nodes
        .map((node) => {
        if (node.nodeType === 3) {
            return node.textContent || '';
        }
        const { nodeName, attributes } = node;
        const serializedAttributes = attributes
            .map(({ name, value }) => ` ${name}="${escapeHTML(String(value))}"`)
            .join('');
        const serializedChildren = serializeHTML(node.childNodes);
        if (['img', 'input', 'br'].includes(nodeName)) {
            return `<${nodeName}${serializedAttributes} />`;
        }
        else {
            return `<${nodeName}${serializedAttributes}>${serializedChildren}</${nodeName}>`;
        }
    })
        .join('');
}
export function renderHTMLContent(template, data, config) {
    var _a;
    const newTemplate = ((_a = config === null || config === void 0 ? void 0 : config.processTemplate) === null || _a === void 0 ? void 0 : _a.call(config, null, template, data)) || template;
    const nodes = parseHTML(newTemplate);
    return renderDOMElement(nodes[0], data, config).outerHTML;
}
//# sourceMappingURL=html.js.map