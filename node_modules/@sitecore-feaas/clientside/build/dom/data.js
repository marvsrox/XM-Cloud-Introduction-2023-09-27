import { JSONPath } from 'jsonpath-plus';
export function cleanCollectionBit(path) {
    return path.replace(/(\[[^\]\[]+\]|\.\*)$/g, '');
}
export function normalizeCollectionScope(path) {
    return cleanCollectionBit(path) + '.*';
}
export function queryScopes(scopes, datapath, singleValue = false, json = scopes) {
    var path = datapath;
    /* find closest parent scope */
    const keys = Object.keys(scopes).sort((b, a) => a.length - b.length);
    for (const scope of keys) {
        if (datapath.startsWith(scope) && 'ends with it') {
            if (scope == datapath) {
                if (singleValue) {
                    return scopes[scope];
                }
                else {
                    continue;
                }
            }
            path = datapath.substring(scope.length + 1);
            json = scopes[scope];
            break;
        }
    }
    var collection = JSONPath({ path, json });
    // If regular path didn't match any data, try fallbacks
    // datasourceId.wrapper.$.path
    if (Array.isArray(collection) && (collection === null || collection === void 0 ? void 0 : collection.length) == 0) {
        collection = [
            // look up in `_` datasource id (catch-all id is used in JSS)
            //   _.wrapper.$.path
            path.replace(/^.*?\./, '_.'),
            // look up directly on data root
            //   wrapper.$.path
            path.replace(/^.*?\./, ''),
            // look up trimmed path in datasource
            //   datasourceId.path
            path.replace(/^([^.]+).*?\.\$\./, '$1.'),
            // look up trimmed path in catch all datasource
            //   _.path
            path.replace(/^.*?\.\$\./, '_.'),
            // look up trimmed path on root
            // path
            path.replace(/^.*?\.\$\./, ''),
            // for case of top-level object data mapping full path can be replaced to _
            path.replace(/^[^.]+$/, '_')
        ]
            .filter((v, i, a) => a.indexOf(v) === i)
            .reduce((v, path) => {
            return v.length > 0 ? v : JSONPath({ path, json });
        }, []);
    }
    if (singleValue && Array.isArray(collection)) {
        return collection[0];
    }
    else {
        return collection;
    }
}
function serializeCH1Tag(data, attrs = {}, tag) {
    if (!tag)
        return serializeCH1RichText(data);
    return `<${tag}${Object.entries(attrs)
        .map(([k, v]) => v != null && ` ${k}="${v}"`)
        .filter(Boolean)
        .join('')}>${serializeCH1RichText(data)}</${tag}>`.replace(/^<([a-z0-9][^>]*)><\/[^>]+>$/, '<$1 />');
}
export function serializeCH1RichText(data) {
    var _a;
    if (Array.isArray(data))
        return data.map(serializeCH1RichText).join('\n').trim();
    if (typeof data == 'string')
        return data;
    if (data == null)
        return '';
    switch (data.type) {
        case 'heading':
            const { level, ...attrs } = data.attrs;
            return serializeCH1Tag(data.content, attrs, 'h' + level);
        case 'text':
            return (data.marks || []).reduce((text, mark) => {
                return serializeCH1Tag(text, mark.attrs, {
                    link: 'a',
                    bold: 'strong',
                    italic: 'em',
                    strike: 's',
                    underline: 'u'
                }[mark.type]);
            }, (_a = data.text) === null || _a === void 0 ? void 0 : _a.replace(/\s+/, ' '));
        default:
            return serializeCH1Tag(data.content || data.text, data.attrs, {
                bulletList: 'ul',
                orderedList: 'ol',
                listItem: 'li',
                horizontalRule: 'hr',
                paragraph: 'p',
                codeBlock: 'code',
                blockquote: 'blockquote'
            }[data.type]);
    }
}
export { JSONPath };
//# sourceMappingURL=data.js.map