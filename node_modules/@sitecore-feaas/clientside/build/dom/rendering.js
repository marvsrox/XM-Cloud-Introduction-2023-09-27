import { normalizeCollectionScope, queryScopes, serializeCH1RichText } from './data.js';
import { parseHTML } from './html.js';
import { loadScript } from './scripts.js';
function getDOMCollectionIndex(element) {
    const datascope = element.getAttribute('data-path-scope');
    var index = 0;
    for (var p = element; (p = p.previousElementSibling);) {
        if (p.getAttribute('data-path-scope') == datascope) {
            index++;
        }
    }
    return index;
}
function updateDOMClones(element, targetCount, config) {
    const datascope = element.getAttribute('data-path-scope');
    if (datascope == null) {
        return;
    }
    var index = getDOMCollectionIndex(element);
    if (index != 0) {
        return;
    }
    const parentElement = element.parentNode;
    if (parentElement == null) {
        return;
    }
    /*dont remove first element, just hide it*/
    if (targetCount == 0) {
        element.setAttribute('hidden', 'hidden');
    }
    else if (element.getAttribute('hidden') != null) {
        element.removeAttribute('hidden');
    }
    var count = index + 1;
    var last = element;
    for (var n = element; (n = n.nextElementSibling);) {
        if (n.getAttribute('data-path-scope') == datascope) {
            count++;
            last = n;
        }
    }
    /* add missing clones */
    for (var i = count; i < targetCount; i++) {
        parentElement.insertBefore(last.cloneNode(true), last.nextElementSibling);
    }
    /* remove excessive clones fron previous renders */
    for (var i = Math.max(1, targetCount); i < count; i++) {
        last = last.previousElementSibling;
        parentElement.removeChild(last.nextElementSibling);
    }
}
export function setDOMAttribute(element, attribute, value, config) {
    var _a;
    if (!element)
        return;
    var target = element;
    if ((value === null || value === void 0 ? void 0 : value.type) == 'doc' && Array.isArray(value.content))
        value = serializeCH1RichText(value);
    if (config === null || config === void 0 ? void 0 : config.processValue) {
        value = config === null || config === void 0 ? void 0 : config.processValue(element, attribute, value);
    }
    var prop = attribute.replace('data-path-', '');
    if (attribute == 'data-path-src') {
        target = element.tagName == 'IMG' ? element : element.querySelector('img, video');
    }
    else if (attribute == 'data-path-href') {
        target = element.querySelector('a') || element.closest('a');
    }
    else if (attribute == 'data-path-alt') {
        target = element.querySelector('img, picture');
    }
    else if (attribute == 'data-path-hidden') {
        value = !value ? true : null;
    }
    else if (attribute == 'data-path' || attribute == 'data-embed-html' || attribute == 'html') {
        prop = 'innerHTML';
    }
    else if (attribute == 'data-embed-src') {
        loadScript(element, value);
    }
    else if (attribute == 'data-path-attributes') {
        const oldKeys = ((_a = element.getAttribute('data-attributes-keys')) === null || _a === void 0 ? void 0 : _a.split(',').filter(Boolean)) || [];
        if (!Array.isArray(value))
            for (var property in value) {
                var subvalue = value[property];
                setDOMAttribute(element, property, typeof subvalue == 'object' && subvalue ? JSON.stringify(subvalue) : subvalue, config);
            }
        for (var i = 0; i < oldKeys.length; i++) {
            if (value == null || !(oldKeys[i] in value)) {
                setDOMAttribute(element, oldKeys[i], null, config);
            }
        }
        setDOMAttribute(element, 'data-attributes-keys', Object.keys(value || {}).join(','));
        return;
    }
    if (typeof value == 'boolean') {
        value = value ? '' : null;
    }
    if (!target)
        return;
    var placeholder = String(element.getAttribute('data-path-placeholder') || target[prop]);
    if (value != null) {
        if (prop == 'innerHTML') {
            if (target.innerHTML != value) {
                target.innerHTML = value;
            }
        }
        else {
            if (target.getAttribute(prop) != value) {
                target.setAttribute(prop, value);
            }
        }
    }
    else {
        if (prop == 'innerHTML') {
            target.innerHTML = placeholder;
        }
        else {
            target.removeAttribute(prop);
        }
    }
}
// order in which attributes are proccesed. Rightmost are more important
var sortOrder = ['data-attributes-keys', 'data-path-attributes', 'data-path-scope'];
export function renderDOMElement(input, datascopes, config, isNested) {
    var _a, _b, _c;
    const element = input;
    if (!isNested) {
        datascopes = ((_a = config === null || config === void 0 ? void 0 : config.processData) === null || _a === void 0 ? void 0 : _a.call(config, element, datascopes)) || datascopes;
    }
    if (element.nodeType == 1) {
        const datascope = element.getAttribute('data-path-scope');
        if (datascope) {
            const index = getDOMCollectionIndex(element);
            const collection = queryScopes(datascopes, datascope, false) || [];
            if (index == 0) {
                updateDOMClones(element, ((_b = config === null || config === void 0 ? void 0 : config.shouldRepeat) === null || _b === void 0 ? void 0 : _b.call(config, element, collection)) === false ? 1 : collection.length, config);
            }
            datascopes = {
                ...datascopes,
                [normalizeCollectionScope(datascope)]: collection[index]
            };
        }
        const attrs = Array.prototype.slice.call(element.attributes).sort((a, b) => {
            return sortOrder.indexOf(a.name) - sortOrder.indexOf(b.name);
        });
        for (var i = 0; i < attrs.length; i++) {
            const { name, value: datapath } = attrs[i];
            if (name.startsWith('data-path') && name != 'data-path-scope') {
                setDOMAttribute(element, name, queryScopes(datascopes, datapath, true), config);
            }
            if (name == 'data-embed-src') {
                setDOMAttribute(element, name, element.getAttribute(name), config);
            }
        }
    }
    for (var i = 0, child; (child = element.childNodes[i++]);) {
        if (isElement(child)) {
            renderDOMElement(child, datascopes, config, true);
        }
    }
    if (!isNested) {
        (_c = config === null || config === void 0 ? void 0 : config.onRender) === null || _c === void 0 ? void 0 : _c.call(config, element, datascopes);
    }
    return element;
}
function isElement(node) {
    return node.nodeType == 1;
}
export function renderDOMContent(root, template, data, config) {
    var _a;
    const newTemplate = ((_a = config === null || config === void 0 ? void 0 : config.processTemplate) === null || _a === void 0 ? void 0 : _a.call(config, root, template, data)) || template;
    root.innerHTML = newTemplate;
    root.classList.add('-feaas');
    // fixme, jss needs to assign theme classes to component instead
    const anchor = root.closest('.component.feaas') || root;
    if (anchor.className.includes('-theme--')) {
        for (var i = 0, child; (child = root.childNodes[i++]);) {
            if (isElement(child)) {
                child.className = child.className.replace(/(\s|^)-theme--[^\s]+\s*/g, '$1');
            }
        }
    }
    return renderDOMElement(root, data, config);
}
export function renderHTMLContent(template, data, config, fakeDOM = false) {
    var _a;
    const newTemplate = ((_a = config === null || config === void 0 ? void 0 : config.processTemplate) === null || _a === void 0 ? void 0 : _a.call(config, null, template, data)) || template;
    if (typeof document === 'undefined' || fakeDOM) {
        const nodes = parseHTML(newTemplate);
        return renderDOMElement(nodes[0], data, config).outerHTML;
    }
    else {
        const root = document.createElement('div');
        root.innerHTML = newTemplate;
        renderDOMElement(root, data, config);
        return root.innerHTML;
    }
}
//# sourceMappingURL=rendering.js.map