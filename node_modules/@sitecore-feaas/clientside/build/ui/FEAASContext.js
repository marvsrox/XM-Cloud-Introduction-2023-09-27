import { FEAASBase } from '../components/FEAASBase.js';
export function FEAASContextProps(element = this) {
    var _a, _b, _c, _d;
    return {
        library: element === null || element === void 0 ? void 0 : element.getAttribute('library'),
        src: (_a = element === null || element === void 0 ? void 0 : element.getAttribute('src')) !== null && _a !== void 0 ? _a : '/context.js',
        frontend: (_b = element === null || element === void 0 ? void 0 : element.getAttribute('frontend')) !== null && _b !== void 0 ? _b : 'https://components.sitecoreclud.io',
        backend: (_c = element === null || element === void 0 ? void 0 : element.getAttribute('backend')) !== null && _c !== void 0 ? _c : 'https://components.sitecoreclud.io/api',
        cdn: (_d = element === null || element === void 0 ? void 0 : element.getAttribute('cdn')) !== null && _d !== void 0 ? _d : 'https://feaas.blob.core.windows.net',
        auth: null,
        isolate: (element === null || element === void 0 ? void 0 : element.getAttribute('isolate')) == null || (element === null || element === void 0 ? void 0 : element.getAttribute('isolate')) == 'true'
    };
}
/**
 * Context provides shared parameters and react providers for its nested elements. It loads lazily once any of its
 * nested components load. Just placing it on the page without any consumers does not impose any overhead.
 */
export class FEAASContext extends FEAASBase {
    constructor() {
        super(...arguments);
        this.defaultProps = {
            isolate: true
        };
        this.onStatusChange = (status) => {
            if (status == 'ready') {
                this.dispatchEvent(new Event('feaasReady', { bubbles: true, composed: true }));
            }
        };
    }
    getProps() {
        return FEAASContextProps(this);
    }
    load() {
        return this.import(this.formatURL(this.props.src, this.props.frontend));
    }
    isReadyToLoad() {
        console.log('Is ready?', this.props, super.isReadyToLoad() && this.props.library != null);
        return super.isReadyToLoad() && this.props.library != null;
    }
    // Remove global styles
    getTheme(theme) {
        return theme;
    }
    getRoot() {
        if (this.getAttribute('isolate') === 'false')
            return this;
        return this.shadowRoot || this.attachShadow({ mode: 'open' });
    }
    getReactRootElement() {
        //if (!this.props.isolate) return this.getRoot()
        if (!this.reactRootElement) {
            this.reactRootElement = document.createElement('div');
            this.getRoot().appendChild(this.reactRootElement);
        }
        return this.reactRootElement;
    }
    /** Pull in children FEAAS react elements into the shadow DOM so they receieve the styles */
    connectedCallback() {
        Array.from(this.children).forEach((child) => {
            this.getRoot().appendChild(child);
        });
        super.connectedCallback();
    }
    render({ children, library }, { AppContext, Chakra: { Button, Tooltip }, React }) {
        const portalProps = {
            containerRef: { current: this.getRoot() }
        };
        Tooltip.defaultProps = {
            hasArrow: true,
            placement: 'top',
            portalProps
        };
        return (React.createElement(AppContext, { backend: this.props.backend, libraryId: this.props.library, container: this.getRoot(), auth: this.props.auth, getTheme: this.getTheme, onStatusChange: this.onStatusChange, modalProps: {
                portalProps
            }, chakraProps: {
                cssVarsRoot: ':host',
                resetCSS: true,
                toastOptions: {
                    portalProps
                }
            } }, children));
    }
}
FEAASContext.observedAttributes = ['library', 'component', 'version', 'revision', 'hostname', 'template'];
FEAASContext.register('feaas-context');
//# sourceMappingURL=FEAASContext.js.map