import { fetchAndRevalidate, fetchWithCacheAwareness, fetchBypassingCache, fetchToValidateCache } from './fetch.js';
export const DEFAULT_CDN_URL = `https://feaas.blob.core.windows.net`;
export function parseComponentSource(source) {
    const match = source.match(/^(?:(.*?)\/components)?\/?([^\/]+)\/([^\/]+)(?:\/([^\/]+)(?:\/(published|staged|saved|\d+)(?:\.html?)?)?)?$/);
    if (match) {
        var [, cdn, library, component, version, revision] = match;
        return { cdn, library, component, version, revision: revision };
    }
}
export function getComponentSource(props) {
    if (!props || !props.library || !props.component)
        throw new Error('Component requires `library` and `component` properties');
    return `${props.cdn && props.cdn != DEFAULT_CDN_URL ? `${props.cdn}/components` : ''}/${props.library}/${props.component}/${!props.version || (props.version == 'responsive' && (!props.revision || props.revision == 'published'))
        ? ''
        : props.version}/${!props.revision || props.revision == 'published' ? '' : props.revision}`.replace(/(^\/|\/$|\/\/)(?!.+\/components\/)/g, '');
}
export function getStylesheetSource(props) {
    return `${props.cdn && props.cdn != DEFAULT_CDN_URL ? `${props.cdn}/styles/` : ''}${props.library}/${!props.revision || props.revision == 'published' ? '' : props.revision}`.replace(/\/$|\/\/(?!.+\/styles\/)/g, '');
}
export function parseStylesheetSource(source) {
    const match = source.match(/^(?:(.*?)\/styles\/)?([^\/]+)(?:\/(published|staged|saved|\d+)(?:.css)?)?$/);
    if (match) {
        var [, cdn, library, revision] = match;
        return { cdn, library, revision: revision };
        // try parsing it as component url
    }
    else {
        const parsed = parseComponentSource(source);
        if (parsed) {
            var { cdn, library, revision } = parsed;
            if (revision === null || revision === void 0 ? void 0 : revision.match(/\d/))
                revision = undefined;
            return { cdn, library, revision: revision };
        }
    }
}
export function getComponentURL(props) {
    if (typeof props == 'string') {
        props = { src: props };
    }
    if ('src' in props) {
        props = {
            ...parseComponentSource(props.src)
        };
    }
    return `${props.cdn || props.hostname || DEFAULT_CDN_URL}/components/${props.library}/${props.component}/${props.version}/${props.revision || 'published'}.html`;
}
export function getStylesheetURL(props) {
    if (typeof props == 'string') {
        props = { src: props };
    }
    if ('src' in props) {
        props = {
            ...parseStylesheetSource(props.src)
        };
    }
    return `${props.cdn || props.hostname || DEFAULT_CDN_URL}/styles/${props.library}/${props.revision || 'published'}.css`;
}
export async function fetchAndRevalidateComponent(props, callback, dontRevalidate = false) {
    const onlyIfNotDeleted = (response) => {
        return response.headers.get('x-ms-meta-versionDeletedAt') == null;
    };
    const parseResponse = (response) => {
        return response.clone().text().then(callback);
    };
    // Fetch two requests in parallel: One optimistically checking if component was forked,
    // and another checking original definition of a component
    const results = await Promise.all([
        props.instance &&
            fetchWithCacheAwareness({
                options: {
                    headers: {
                        Accept: 'text/html'
                    },
                    credentials: 'omit'
                },
                url: getComponentURL({ ...props, version: props.instance }),
                validator: onlyIfNotDeleted
            }).catch((e) => e),
        fetchWithCacheAwareness({ url: getComponentURL(props), validator: onlyIfNotDeleted }).catch((e) => e)
    ]);
    const result = results.find((result) => result && 'isCached' in result && result);
    if (!result || result instanceof Error) {
        const error = results.find((result) => result && result instanceof Error);
        throw error || new Error('Can not fetch component');
    }
    if (results[0] == result) {
        console.log('Using fork!', results);
    }
    await parseResponse(result.response);
    if (dontRevalidate)
        return result;
    return fetchToValidateCache({ ...result, callback: parseResponse }).catch((e) => {
        if (results[0] == result) {
            fetchBypassingCache({ ...result, callback: null, validator: null });
            console.log('Fork was deleted');
            // forked version was cached, but it's now deleted
            if (!(results[1] instanceof Error)) {
                parseResponse(results[1].response);
                return fetchToValidateCache({ ...results[1], callback: parseResponse });
            }
        }
        throw e;
    });
}
/** Fetches HTML of a component. */
export async function fetchComponent(props) {
    if (typeof props == 'string')
        props = { src: props };
    var template;
    const { response } = await fetchAndRevalidateComponent(props, (result) => {
        template = result;
    }, true);
    return { ...props, template, lastModified: response.headers.get('last-modified') };
}
export async function fetchAndRevalidateStylesheet(props, callback) {
    if (typeof props == 'string')
        props = { src: props };
    return fetchAndRevalidate(getStylesheetURL(props), {
        headers: {
            Accept: 'text/css'
        },
        credentials: 'omit'
    }, (response) => {
        return response.headers.get('x-ms-meta-deletedAt') == null;
    }, (response, phase) => {
        return response
            .clone()
            .text()
            .then((text) => callback(text, phase));
    });
}
//# sourceMappingURL=cdn.js.map